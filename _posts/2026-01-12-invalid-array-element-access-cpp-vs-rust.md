---
title: "Invalid array element access in C++ and in Rust"
date: 2026-01-12
category: cpp-vs-rust
tags: rust, cpp, gdb
---

## Invalid Array Element Access in Rust

Let's quote the Rust Book Section 3.2, "Invalid Array Element Access" : [https://doc.rust-lang.org/stable/book/ch03-02-data-types.html?highlight=Index%20entered#invalid-array-element-access](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html?highlight=Index%20entered#invalid-array-element-access).

> Let’s see what happens if you try to access an element of an array that is past the end of the array. Say you run this code, similar to the guessing game in Chapter 2, to get an array index from the user:
> 
> Filename: src/main.rs
> ```rust
> use std::io;
> 
> fn main() {
>     let a = [1, 2, 3, 4, 5];
> 
>     println!("Please enter an array index.");
> 
>     let mut index = String::new();
> 
>     io::stdin()
>         .read_line(&mut index)
>         .expect("Failed to read line");
> 
>     let index: usize = index
>         .trim()
>         .parse()
>         .expect("Index entered was not a number");
> 
>     let element = a[index];
> 
>     println!("The value of the element at index {index} is: {element}");
> }
> ```
> 
> This code compiles successfully. If you run this code using `cargo run` and enter `0`, `1`, `2`, `3`, or `4`, the program will print out the corresponding value at that index in the array. If you instead enter a number past the end of the array, such as `10`, you’ll see output like this:
> 
> ```
> thread 'main' panicked at src/main.rs:19:19:
> index out of bounds: the len is 5 but the index is 10
> note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
> ```

TLDR: Rust will panic if you try to access an invalid array element.

## Invalid Array Element Access in C++

### To segfault or not to segfault

The equivalent code in C++ can lead to a segfault, but not necessarily.

```cpp
#include <iostream>

int main() {
    int array[] = { 1, 2, 3, 4, 5 };

    // Generated by ChatGPT : Begin
    std::string line;
    if (!std::getline(std::cin, line)) return 0; // read a full line from stdin

    long long i = 0; // result number
    for (char c : line) {
        // assuming only '0'..'9' appear in the input
        i = i * 10 + (c - '0');
    }
    // Generated by ChatGPT : End

    std::cout << array[i] << std::endl;
}
```

I compiled the program above using `g++ main.cpp` and tried different input numbers to see whether it would segfault or not. It turns out we're missing information to make predictions : the same executable with the same input number can give different results. 

```sh
./a.out
1000
# here some random number
```

```sh
./a.out
10000
[1]    39967 segmentation fault (core dumped)  ./a.out
```

```sh
./a.out
3093
# sometimes it segfaults, sometimes not
```

In my case, it seems that I can always read at least some invalid array elements. I noticed that this also works with *negative* array elements, you can check this by using `array[-i]` in the last line of the program.

### Undefined behaviour can still be fun

Accessing invalid array elements in C++ is [UB](https://en.cppreference.com/w/cpp/language/ub.html), which means that compilers have no restriction on what they can output if you read an invalid element. This means that while they *could* output the value actually stored at the underlying address (which seems like the most simple option), or they could do something else entirely.

In my case (`g++ (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0`), I was pleased to see that I can actually read neighboring addresses of my array, so I had some fun with gdb to design the following program.

```cpp
#include <iostream>

int main() {
    int array[] = { 1, 2, 3, 4, 5 };
    int secret = 47;

    std::cout << "The secret is " << array[-1] << std::endl;
}
```

This program reads the content of the `secret` variable without actually using the variable. Of course, this program can't be assumed to work on another compiler, but I'll show you how to design one for your compiler.

### Using GBD

First compile your program with debug symbols.

```sh
g++ -g main.cpp
```

Then run gdb and print the addresses of `secret` and `array`:
```sh
(gdb) b main # set a breakpoint on the `main` function
(gdb) r # run, execution should stop when entering `main`
(gdb) p/x &array
$2 = 0x7fffffffd2c0
(gdb) p/x &secret
$3 = 0x7fffffffd2bc
```

In my case, `array` is located 4 bytes after `secret`, so I deduce that I can read `secret` with `array[-1]`. To check this more thoroughly, let's execute the code up until the print statement :

```sh
(gdb) layout src # to see the source code, use Ctrl+x Ctrl+a to go back to regular commands with autocomplete, history and copy-paste
(gdb) b main.cpp:7 # the print statement is on line 7
(gdb) c
(gdb) p secret@6 # print variable `secret` and the following bytes, supposing there's 6 consecutive variables with the same type
$13 = {47, 1, 2, 3, 4, 5}
```

Now I'm a 100% sure that `secret` is in `array[-1]`.

### Address sanitizing

Don't worry, C++ can actually detect invalid array element access using address sanitizing.

```sh
g++ -fsanitize=address -g main.cpp
./a.out
=================================================================
==50764==ERROR: AddressSanitizer: stack-buffer-underflow on address 0x798d8100001c at pc 0x5598a8b2a4b6 bp 0x7ffc0853bc90 sp 0x7ffc0853bc80
READ of size 4 at 0x798d8100001c thread T0
    #0 0x5598a8b2a4b5 in main hacking.cpp:7
    #1 0x798d8302a1c9 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #2 0x798d8302a28a in __libc_start_main_impl ../csu/libc-start.c:360
    #3 0x5598a8b2a1c4 in _start (a.out+0x11c4) (BuildId: ca5edb2252162616e4eb89f42fa09b7b8a79bb50)

Address 0x798d8100001c is located in stack of thread T0 at offset 28 in frame
    #0 0x5598a8b2a298 in main hacking.cpp:3

  This frame has 1 object(s):
    [32, 52) 'array' (line 4) <== Memory access at offset 28 underflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-underflow hacking.cpp:7 in main
Shadow bytes around the buggy address:
  0x798d80fffd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d80fffe00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d80fffe80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d80ffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d80ffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x798d81000000: f1 f1 f1[f1]00 00 04 f3 f3 f3 f3 f3 00 00 00 00
  0x798d81000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d81000100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d81000180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d81000200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x798d81000280: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==50764==ABORTING
```

However, there are still a big differences with Rust :
- Rust can catch obvious out-of-bounds issues *during compilation*.

```rs
fn main() {
    let array = [1, 2, 3, 4, 5];
    
    println!("{}", array[6]); // error: this operation will panic at runtime
}
```

```rs
fn main() {
    let array = [1, 2, 3, 4, 5];
    
    println!("{}", array[-1]); // error: negative integers cannot be used to index on a `[{integer}; 5]`
}
```

```rs
fn main() {
    let array = [1, 2, 3, 4, 5];
    
    for i in 0..6 {
        println!("{}", array[i]); // compiles but panics at runtime
    }
}
```

- when there's a runtime panic, the message is much more understandable :

```sh
thread 'main' (12) panicked at src/main.rs:6:24:
index out of bounds: the len is 5 but the index is 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```


### The Dawn Of C++26

Friends tell me C++ 26 has improved memory safety but I haven't tested it yet !




